<html>
  <head>
    <title>Gripes with wordpress's postmeta and autoload</title>
    <meta name="description" content="Ethan Eldridge's personal website"/>
	<meta name="keywords" content="Ethan,Eldridge,Joachim,Programming"/>
	<meta charset=utf-8 />
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />

    <link rel='stylesheet' href='/main.css' />
    <script src="/js/app.js"></script>
    <meta name="description" content="Personal website of Ethan Joachim Eldridge. Resume, blog, cooking, writing and more" />
  </head>
  <body>
  	<h1 id="huge">Ethan Joachim Eldridge: A Programmer.</h1>

<ol>
	<li><a href="/index.html">Home</a></li>
	<li><a href="https://github.com/EJEHardenberg">Github</a></li>
	<li><a href="/write">Writing</a></li>
	<li><a href="/projects">Projects</a></li>
	<li><a href="/resume">Resume</a></li>
	<li><a href="//ejehardenberg.github.io/cooking">Cooking</a></li>
</ol>



    <h3>A few words (and gripes) on Wordpress Indexes</h3>
<p>Let me just start off with this note. Wordpress is a fantastically 
documented framework. The <a href="http://codex.wordpress.org">Codex</a> is one of the most beautifully 
styled and (mostly) cleanly written details I&#39;ve seen. I love it. Also,
Wordpress is great for what it&#39;s designed to do. Blogging (I personally
prefer using <a href="harpjs.com">Harp</a> but that&#39;s just me).</p>
<p>And before I really get into this, let me just re-iterate that the thoughts 
on this blogpost and any of my others are mine and not the company I work
for, etc. etc.</p>
<p>A default install will, with a good caching plugin like <a href="http://wordpress.org/plugins/w3-total-cache/">w3tc</a> or
<a href="https://wordpress.org/plugins/wp-super-cache/">super cache</a>, scale out fairly well for a blog. Because the blogs content,
though generated by PHP and the database underneath, can be cached since it
doesn&#39;t really change much. For logged in users you get some changes
neccesary, but hey, it&#39;s do-able.</p>
<p>Unfortunately, a lot of people use wordpress for things it&#39;s not made for,
like <a href="http://wordpress.org/plugins/tags/ecommerce">e-commerce</a>. I&#39;ve had the unfortunate pleasure of dealing with a
plugin that causes your site to change into a Group-On clone. A nice thought, 
except for the fact that this particular plugin decided to do things
&quot;the wordpress way&quot;. What does this mean? </p>
<p>It mean&#39;s that everything. Products, Customers, Purchases, coupons, you
name it, is stuffed into the <code>wp_posts</code> table and the extra information
is placed into <code>wp_postmeta</code>. This fits into Wordpress&#39;s EAV model. Long
and skinny and easily extendable. Sounds great for something where people
want to put whatever information they want about their products onto a 
page with minimal effort. </p>
<p>Except for this simple fact. </p>
<p>The <code>wp_postmeta</code> table is designed to hold <em>anything</em>, so the <code>meta_value</code>
column is a <code>LONGTEXT</code> field. What&#39;s the problem with that you might ask? 
When someone does a query like this:</p>
<pre><code>SELECT * from wp_posts wp 
INNER JOIN wp_postmeta wpm ON wp.ID = wpm.post_id 
WHERE meta_value = &#39;X&#39; 
GROUP BY wp.ID ORDER BY wp.post_date_gmt</code></pre>
<p>This seems like a perfectly harmless query. Doing an explain reveals this:</p>
<pre><code>*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: wp
         type: index
possible_keys: PRIMARY,post_name,type_status_date,post_parent,post_author
          key: PRIMARY
      key_len: 8
          ref: NULL
         rows: 31
        Extra: Using temporary; Using filesort
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: wpm
         type: ref
possible_keys: post_id
          key: post_id
      key_len: 8
          ref: shortcodes.wp.ID
         rows: 2
        Extra: Using where</code></pre>
<p>Also doesn&#39;t seem that bad right? Yes, it&#39;s using a temporary and a filesort but
the <code>JOIN</code> itself is fast right? Yes the join is fast, <code>PRIMARY</code> key is great. The 
number of rows in this small test database result in a query that takes 0.09s on
my machine. But if I switch to a much larger database? </p>
<pre><code>*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: wp
         type: index
possible_keys: PRIMARY,post_name,post_parent,post_author
          key: PRIMARY
      key_len: 8
          ref: NULL
         rows: 168203
        Extra: Using temporary; Using filesort
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: wpm
         type: ref
possible_keys: post_id
          key: post_id
      key_len: 8
          ref: testdb.wp.ID
         rows: 2
        Extra: Using where
2 rows in set (0.00 sec)

mysql&gt; SELECT * from wp_posts wp      INNER JOIN wp_postmeta wpm ON wp.ID = wpm.post_id      WHERE meta_value = &#39;X&#39;      GROUP BY wp.ID ORDER BY wp.    post_date_gmt\G 
Empty set (34.33 sec)</code></pre>
<p>That&#39;s right kids, 34.33 seconds. On a database with 168,203 rows in it&#39;s posts 
table. That seems like a lot, but when you have plugins that stuff <em>everything</em>
into that table, it&#39;s really not and is more common than you think.</p>
<p>So why is it slow? The problem lies in the <code>LONGTEXT</code>, because in order to do our
query we&#39;re making a temporary table of our join, and we&#39;re sorting that. And it&#39;s
the <code>ORDER BY</code> and <code>GROUP BY</code> that are taking a toll on us. If I run the same query
without those two, it takes 2.78s to execute. Still an awful time for a database
to spend on a single query, but much much better than 34.33 seconds. </p>
<p>The temporary table is what really kills us, if you were to do an explain you&#39;d 
see that the <code>filesort</code> and <code>temporary</code> extra&#39;s are gone. Because we have to pull
down all the <code>LONGTEXT</code> fields associated with ALL of posts that have meta information
we get clogged up on our disk I/O. Since the <code>LONGTEXT</code> can store up to 4GB (last time
I checked the mySQL documentation anyway), we&#39;re potentially pulling down a lot of
information per row, and that&#39;s not going to fit into RAM, especially not with that
many rows being acted on by our query. </p>
<p>Really, the solution here is to rewrite your query in some clever way and also to
apply partial indexes to your <code>meta_value</code> column so that we can get some speed. 
Also, if your queries are doing other <code>JOIN</code>s and <code>WHERE</code>s that you&#39;ll want to 
try to make an index that fully covers what you&#39;re querying against. I found a
<a href="http://www.slideshare.net/billkarwin/how-to-design-indexes-really">great slideshow</a> detailing some methods on making indexes work correctly and I
suggest it to anyone trying to really understand what they can do to make their
database a little more optimized.  </p>
<p>Finally, my other biggest gripe is something that flabbergasted me yesterday when
I realized it. </p>
<p><em>Wordpress does not have an index on the <code>autoload</code> column of it&#39;s <code>wp_options</code> 
table. </em></p>
<p><code>wp_options</code> is the table designed to hold your options (well named right?), so
plugins store setup information, wordpress stores how you want your dates to be
shown, and there&#39;s tons more. Unfortunately, plugin developers often put a lot
of things into the options table because it&#39;s so easy to use. The <code>autoload</code> 
column decides whether or not the option should be pulled down from the database
when Wordpress boots up. So I see a query like this on start up a lot:</p>
<pre><code>SELECT option_name, option_value FROM wp_options WHERE autoload=&#39;yes&#39;</code></pre>
<p>On a clients webpage, this query took 40+ seconds. While this was due primarily 
to being clogged up on queries like the one mentioned above, it showed up in the
slow query log and I investigated it. After fooling around, I ended up adding
an index to the autoload column to help it. Why? Because without the index the
full wp_options table has to be scanned, for this client that&#39;s 15681 rows (see
why I don&#39;t like Wordpress being used as a platform to do things it shouldn&#39;t?),
when I add an index, the number of rows scanned is reduced to 229. That&#39;s a huge 
boost. </p>
<p>Really, I was confused why <code>autoload</code> isn&#39;t indexed by default. A quick perusal of
<code>wp-includes/options.php</code> in a wordpress install will show that the the function
<code>wp_load_alloptions</code> calls into the database with this query, and searching for 
the use of that function will turn up that it&#39;s used on every page load since, as
I said previously, it&#39;s called on every page request. This seems like an oversight
to me, granted that I doubt the core wordpress developers felt that people would
abuse the options table like it has been in this particular case, but it&#39;s still
something I would expect from people as smart as them. I wouldn&#39;t consider indexing
that column to be a pre-optimization either (an argument I imagine they might make).</p>
<p>Wordpress is a great blogging platform. It would be great if, when people tried to 
use it for other areas, that they don&#39;t blindly follow the &quot;wordpress way&quot;, and 
instead focus on good normalized schema design. Just my 2 cents.</p>

    

  
      <a class="floatleft" href=varnish>Varnish and API Servers</a>
  

  
      <a class="floatright" href=resource-replace>Resource Replace, update js and css domain links</a>
  
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'ejehardenberg'; // required: replace example with your forum shortname
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <div id="footer">
      <p>Copyright (c) Ethan Eldridge</p>
    </div>
  </body>
</html>